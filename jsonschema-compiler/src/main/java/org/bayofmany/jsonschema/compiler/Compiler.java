package org.bayofmany.jsonschema.compiler;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.CharMatcher;
import com.google.common.base.Preconditions;
import com.squareup.javapoet.*;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import org.apache.commons.lang3.StringUtils;
import org.bayofmany.jsonschema.model.JsonSchema;
import org.bayofmany.jsonschema.validation.constraints.MaxItems;
import org.bayofmany.jsonschema.validation.constraints.MinItems;
import org.bayofmany.jsonschema.validation.constraints.MultipleOf;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Generated;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Modifier;
import javax.validation.constraints.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;


public class Compiler {

    private static final Logger log = LoggerFactory.getLogger(Compiler.class);

    private final File outputDir;

    public Compiler(File outputDir) {
        this.outputDir = outputDir;
    }

    private TypeSpec compile(JsonSchema schema) throws IOException {
        if (schema.isArrayType()) {
            return null;
        }

        String className = ((ClassName) schema.meta.getType()).simpleName();
        if (schema.enumeration != null) {
            return generateEnum(className, schema);
        }

        TypeSpec.Builder type = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC);

        AnnotationSpec generated = AnnotationSpec.builder(Generated.class)
                .addMember("value", "$S", Compiler.class.getName())
                .addMember("date", "$S", LocalDate.now())
                .addMember("comments", "$S", "Generated by jsonschema-maven-plugin")
                .build();
        type.addAnnotation(generated);

        if (schema.title != null || schema.description != null) {
            AnnotationSpec.Builder apiModel = AnnotationSpec.builder(ApiModel.class);
            if (schema.title != null) {
                apiModel.addMember("value", "$S", schema.title);
            }
            if (schema.description != null) {
                apiModel.addMember("description", "$S", schema.description);
            }
            type.addAnnotation(apiModel.build());
        }


        if (schema.properties != null) {
            for (Map.Entry<String, JsonSchema> entry : schema.properties.getAdditionalProperties().entrySet()) {
                String fieldName = lowerCaseFirst(escapePredefined(entry.getKey()));
                JsonSchema s = entry.getValue();

                TypeName propertyType = s.meta.getType();
                if (s.enumeration != null) {
                    TypeSpec enumSpec = generateEnum(upperCaseFirst(fieldName), s);
                    type.addType(enumSpec);
                }

                FieldSpec.Builder field = FieldSpec.builder(propertyType, fieldName).addModifiers(Modifier.PRIVATE);

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1
                if (s.multipleOf != null && s.isNumericType()) {
                    field.addAnnotation(AnnotationSpec.builder(MultipleOf.class).addMember("value", "$L", s.multipleOf).build());
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2
                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3
                if (s.maximum != null && s.isNumericType()) {
                    if (s.maximum.longValue() == s.maximum) {
                        if (s.exclusiveMaximum == Boolean.TRUE) {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMax.class).addMember("value", "$S", s.maximum).addMember("inclusive", "$L", Boolean.FALSE).build());
                        } else {
                            field.addAnnotation(AnnotationSpec.builder(Max.class).addMember("value", "$LL", s.maximum.longValue()).build());
                        }
                    } else {
                        if (s.exclusiveMaximum == Boolean.TRUE) {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMax.class).addMember("value", "$S", s.maximum).addMember("inclusive", "$L", Boolean.FALSE).build());
                        } else {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMax.class).addMember("value", "$S", s.maximum).build());
                        }
                    }
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4
                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5
                if (s.minimum != null && s.isNumericType()) {
                    if (s.minimum.longValue() == s.minimum) {
                        if (s.exclusiveMinimum == Boolean.TRUE) {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMin.class).addMember("value", "$S", s.minimum).addMember("inclusive", "$L", Boolean.FALSE).build());
                        } else {
                            field.addAnnotation(AnnotationSpec.builder(Min.class).addMember("value", "$LL", s.minimum.longValue()).build());
                        }
                    } else {
                        if (s.exclusiveMinimum == Boolean.TRUE) {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMin.class).addMember("value", "$S", s.minimum).addMember("inclusive", "$L", Boolean.FALSE).build());
                        } else {
                            field.addAnnotation(AnnotationSpec.builder(DecimalMin.class).addMember("value", "$S", s.minimum).build());
                        }
                    }
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.6
                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.7
                if (s.isStringType() && (s.minLength != null || s.maxLength != null)) {
                    AnnotationSpec.Builder size = AnnotationSpec.builder(Size.class);
                    if (s.minLength != null) {
                        size.addMember("min", "$L", s.minLength);
                    }
                    if (s.maxLength != null) {
                        size.addMember("max", "$L", s.maxLength);
                    }
                    field.addAnnotation(size.build());
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.8
                if (s.pattern != null && s.isStringType()) {
                    field.addAnnotation(AnnotationSpec.builder(Pattern.class).addMember("regexp", "$S", s.pattern).build());
                }


                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.10
                if (s.maxItems != null && s.isArrayType()) {
                    field.addAnnotation(AnnotationSpec.builder(MaxItems.class).addMember("value", "$L", s.maxItems).build());
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.11
                if (s.minItems != null && s.isArrayType()) {
                    field.addAnnotation(AnnotationSpec.builder(MinItems.class).addMember("value", "$L", s.minItems).build());
                }

                // @see http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.15
                if (schema.required.contains(fieldName)) {
                    field.addAnnotation(NotNull.class);
                }

                if (s.description != null) {
                    field.addAnnotation(AnnotationSpec.builder(ApiModelProperty.class).addMember("notes", "$S", s.description).build());
                }
                field.addAnnotation(AnnotationSpec.builder(JsonProperty.class).addMember("value", "$S", entry.getKey()).build());

                type.addField(field.build());

                MethodSpec getter = MethodSpec.methodBuilder("get" + upperCaseFirst(fieldName))
                        .addModifiers(Modifier.PUBLIC)
                        .returns(propertyType)
                        .addStatement("return $N", fieldName)
                        .build();

                MethodSpec setter = MethodSpec.methodBuilder("set" + upperCaseFirst(fieldName))
                        .addModifiers(Modifier.PUBLIC)
                        .returns(void.class)
                        .addParameter(propertyType, fieldName)
                        .addStatement("this.$N = $N", fieldName, fieldName)
                        .build();

                type.addMethod(getter).addMethod(setter);
            }
        }


        if (schema.additionalPropertiesBoolean != Boolean.FALSE) {
            TypeName propertiesType = schema.additionalPropertiesSchema == null ? TypeName.OBJECT : schema.additionalPropertiesSchema.meta.getType();
            ParameterizedTypeName mapType = ParameterizedTypeName.get(ClassName.get(Map.class), TypeName.get(String.class), propertiesType);
            type.addField(FieldSpec.builder(mapType, "additionalProperties")
                    .addModifiers(Modifier.PRIVATE)
                    .addAnnotation(JsonIgnore.class)
                    .build());

            MethodSpec getter = MethodSpec.methodBuilder("getAdditionalProperties")
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(String.class, "name")
                    .addAnnotation(JsonAnyGetter.class)
                    .returns(propertiesType)
                    .addStatement("return additionalProperties.get(name)")
                    .build();

            MethodSpec setter = MethodSpec.methodBuilder("setAdditionalProperty")
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(String.class, "name")
                    .addParameter(propertiesType, "value")
                    .returns(void.class)
                    .addStatement("this.additionalProperties.put(name, value)")
                    .build();

            type.addMethod(getter).addMethod(setter);
        }

        if (schema.definitions != null) {
            for (JsonSchema schema1 : schema.definitions.getAdditionalProperties().values()) {
                if (schema1.isInlineType()) {
                    continue;
                }

                TypeSpec spec = compile(schema1);
                if (spec == null) {
                    continue;
                }

                JavaFile javaFile = JavaFile.builder(schema.meta.packageName, spec).build();
                javaFile.writeTo(outputDir);
            }
        }

        return type.build();
    }


    private TypeSpec generateEnum(String className, JsonSchema schema) {
        Preconditions.checkArgument(schema.enumeration != null, "No support for empty enumerations");

        TypeSpec.Builder enumeration = TypeSpec.enumBuilder(className).addModifiers(Modifier.PUBLIC);

        if (schema.enumerationLiterals == null) {
            boolean allStrings = Arrays.stream(schema.enumeration).allMatch((e -> (e instanceof String)));
            if (allStrings) {
                Optional<Boolean> allValid = Arrays.stream(schema.enumeration).map(o -> SourceVersion.isName((String) o)).reduce(Boolean::logicalAnd);
                if (allValid.isPresent() && allValid.get()) {
                    for (Object o : schema.enumeration) {
                        enumeration.addEnumConstant((String) o);
                    }
                    return enumeration.build();
                }
            }
        }

        TypeName valueType;
        if (schema.isPrimitiveType()) {
            valueType = schema.meta.getPrimitiveType();
        } else {
            List<Class<?>> classes = Arrays.stream(schema.enumeration).map(Object::getClass).distinct().collect(Collectors.toList());
            valueType = classes.size() == 1 ? TypeName.get(classes.get(0)) : TypeName.OBJECT;
        }


        if (schema.enumerationLiterals != null) {
            Preconditions.checkArgument(schema.enumeration.length == schema.enumerationLiterals.length, "x-bayofmany-enumLiterals must have the same number of values than enum");
            for (String literal : schema.enumerationLiterals) {
                Preconditions.checkArgument(SourceVersion.isName(literal), literal + "is an invalid enum literal");
            }
        }

        for (int i = 0; i < schema.enumeration.length; i++) {
            Object o = schema.enumeration[i];

            String name;
            if (o == null) {
                name = "NULL";
            } else if (schema.enumerationLiterals != null) {
                name = schema.enumerationLiterals[i];
            } else {
                name = CharMatcher.javaLetterOrDigit().negate().replaceFrom(o.toString(), '_').toUpperCase();
            }
            if (name.matches("^\\d.*")) {
                name = "_" + name;
            } else if (name.isEmpty()) {
                name = "EMPTY";
            }

            String format = o instanceof String ? "$S" : "$L";
            if (TypeName.DOUBLE.box().equals(valueType)) {
                format = format + "d";
            } else if (TypeName.LONG.box().equals(valueType)) {
                format = format + "L";
            }
            enumeration.addEnumConstant(name, TypeSpec.anonymousClassBuilder(format, o).build());
        }

        enumeration.addField(valueType, "value");
        enumeration.addMethod(MethodSpec.constructorBuilder()
                .addParameter(valueType, "value")
                .addStatement("this.value = value")
                .build());

        return enumeration.build();
    }

    private String escapePredefined(String fieldName) {
        fieldName = fieldName.trim();
        if (fieldName.contains("-") || fieldName.contains("_")) {
            StringBuilder builder = new StringBuilder();
            for (String part : fieldName.split("[-_ ]")) {
                builder.append(upperCaseFirst(part));
            }
            fieldName = builder.toString();
        }
        return SourceVersion.isKeyword(fieldName) ? "_" + fieldName : fieldName;
    }

    public void generate(Path folder, String packageName) throws IOException {
        Dictionary dictionary = new Dictionary();
        Files.newDirectoryStream(folder, entry -> entry.toString().endsWith(".json")).forEach(p -> {
            String fileName = StringUtils.substringAfterLast(p.toUri().toString(), "/");

            try {
                ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY).enable(JsonParser.Feature.ALLOW_COMMENTS);
                JsonSchema jsonSchema = mapper.readValue(p.toFile(), JsonSchema.class);
                jsonSchema.visitSchemaDefinitions(fileName, packageName, dictionary);
            } catch (IOException e) {
                log.error("Error parsing file " + fileName, e);
            }
        });

        dictionary.getRootSchemas().forEach(schema -> {
            try {
                TypeSpec type = compile(schema);
                if (type != null) {
                    JavaFile.builder(schema.meta.packageName, type).build().writeTo(outputDir);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

    }

    private String upperCaseFirst(String name) {
        return name.substring(0, 1).toUpperCase() + name.substring(1);
    }

    private String lowerCaseFirst(String name) {
        return name.substring(0, 1).toLowerCase() + name.substring(1);
    }
}
